package activitypub

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"strings"
	"testing"
	"time"

	"github.com/deemkeen/stegodon/domain"
	"github.com/google/uuid"
)

func TestAcceptActivityGeneration(t *testing.T) {
	// Test the structure of Accept activity generated by SendAccept logic
	followID := "https://mastodon.social/follows/123"
	acceptID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	accept := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       acceptID,
		"type":     "Accept",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  remoteActorURI,
			"object": actorURI,
		},
	}

	// Verify structure can be marshaled
	jsonBytes, err := json.Marshal(accept)
	if err != nil {
		t.Fatalf("Failed to marshal Accept activity: %v", err)
	}

	// Parse back to verify structure
	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Accept: %v", err)
	}

	if parsed["type"] != "Accept" {
		t.Errorf("Expected type Accept, got %v", parsed["type"])
	}
	if parsed["actor"] != actorURI {
		t.Errorf("Expected actor %s, got %v", actorURI, parsed["actor"])
	}

	// Verify embedded object
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Follow" {
		t.Error("Expected embedded object type Follow")
	}
	if obj["id"] != followID {
		t.Error("Expected embedded object to reference original Follow")
	}
}

func TestCreateActivityGeneration(t *testing.T) {
	// Test Create activity structure for notes
	noteId := uuid.New()
	createdAt := time.Now()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	createID := "https://stegodon.example/activities/" + uuid.New().String()

	create := map[string]any{
		"@context":  "https://www.w3.org/ns/activitystreams",
		"id":        createID,
		"type":      "Create",
		"actor":     actorURI,
		"published": createdAt.Format(time.RFC3339),
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": map[string]any{
			"id":           noteURI,
			"type":         "Note",
			"attributedTo": actorURI,
			"content":      "Test note content",
			"published":    createdAt.Format(time.RFC3339),
			"to": []string{
				"https://www.w3.org/ns/activitystreams#Public",
			},
			"cc": []string{
				"https://stegodon.example/users/alice/followers",
			},
		},
	}

	jsonBytes, err := json.Marshal(create)
	if err != nil {
		t.Fatalf("Failed to marshal Create activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Create: %v", err)
	}

	if parsed["type"] != "Create" {
		t.Error("Expected type Create")
	}

	// Verify addressing
	to := parsed["to"].([]any)
	if len(to) != 1 || to[0] != "https://www.w3.org/ns/activitystreams#Public" {
		t.Error("Expected public addressing in to field")
	}

	cc := parsed["cc"].([]any)
	if len(cc) != 1 {
		t.Error("Expected followers in cc field")
	}

	// Verify embedded Note
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Note" {
		t.Error("Expected embedded object type Note")
	}
	if obj["content"] != "Test note content" {
		t.Error("Expected note content in object")
	}
}

func TestUpdateActivityGeneration(t *testing.T) {
	// Test Update activity structure
	noteId := uuid.New()
	createdAt := time.Now().Add(-1 * time.Hour)
	editedAt := time.Now()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	updateID := "https://stegodon.example/activities/" + uuid.New().String()

	update := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       updateID,
		"type":     "Update",
		"actor":    actorURI,
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": map[string]any{
			"id":           noteURI,
			"type":         "Note",
			"attributedTo": actorURI,
			"content":      "Updated content",
			"published":    createdAt.Format(time.RFC3339),
			"updated":      editedAt.Format(time.RFC3339),
			"to": []string{
				"https://www.w3.org/ns/activitystreams#Public",
			},
			"cc": []string{
				"https://stegodon.example/users/alice/followers",
			},
		},
	}

	jsonBytes, err := json.Marshal(update)
	if err != nil {
		t.Fatalf("Failed to marshal Update activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Update: %v", err)
	}

	if parsed["type"] != "Update" {
		t.Error("Expected type Update")
	}

	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Note" {
		t.Error("Expected embedded object type Note")
	}

	// Verify both published and updated timestamps
	if obj["published"] == nil {
		t.Error("Expected published timestamp")
	}
	if obj["updated"] == nil {
		t.Error("Expected updated timestamp")
	}
}

func TestDeleteActivityGeneration(t *testing.T) {
	// Test Delete activity structure
	noteId := uuid.New()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	deleteID := "https://stegodon.example/activities/" + uuid.New().String()

	deleteActivity := map[string]any{
		"@context":  "https://www.w3.org/ns/activitystreams",
		"id":        deleteID,
		"type":      "Delete",
		"actor":     actorURI,
		"published": time.Now().Format(time.RFC3339),
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": noteURI,
	}

	jsonBytes, err := json.Marshal(deleteActivity)
	if err != nil {
		t.Fatalf("Failed to marshal Delete activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Delete: %v", err)
	}

	if parsed["type"] != "Delete" {
		t.Error("Expected type Delete")
	}

	// In Delete, object is just a URI string
	if parsed["object"] != noteURI {
		t.Errorf("Expected object to be URI %s", noteURI)
	}
}

func TestFollowActivityGeneration(t *testing.T) {
	// Test Follow activity structure
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	follow := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       followID,
		"type":     "Follow",
		"actor":    actorURI,
		"object":   remoteActorURI,
	}

	jsonBytes, err := json.Marshal(follow)
	if err != nil {
		t.Fatalf("Failed to marshal Follow activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Follow: %v", err)
	}

	if parsed["type"] != "Follow" {
		t.Error("Expected type Follow")
	}
	if parsed["actor"] != actorURI {
		t.Error("Expected local actor URI")
	}
	if parsed["object"] != remoteActorURI {
		t.Error("Expected remote actor URI in object")
	}
}

func TestActivityURIGeneration(t *testing.T) {
	// Test that URIs are properly formatted
	tests := []struct {
		name     string
		domain   string
		username string
		id       string
		uriType  string
		expected string
	}{
		{
			name:     "actor URI",
			domain:   "stegodon.example",
			username: "alice",
			uriType:  "actor",
			expected: "https://stegodon.example/users/alice",
		},
		{
			name:     "activity URI",
			domain:   "stegodon.example",
			id:       uuid.New().String(),
			uriType:  "activity",
			expected: "https://stegodon.example/activities/",
		},
		{
			name:     "note URI",
			domain:   "stegodon.example",
			id:       uuid.New().String(),
			uriType:  "note",
			expected: "https://stegodon.example/notes/",
		},
		{
			name:     "followers URI",
			domain:   "stegodon.example",
			username: "alice",
			uriType:  "followers",
			expected: "https://stegodon.example/users/alice/followers",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var uri string
			switch tt.uriType {
			case "actor":
				uri = "https://" + tt.domain + "/users/" + tt.username
			case "activity":
				uri = "https://" + tt.domain + "/activities/" + tt.id
			case "note":
				uri = "https://" + tt.domain + "/notes/" + tt.id
			case "followers":
				uri = "https://" + tt.domain + "/users/" + tt.username + "/followers"
			}

			if !strings.HasPrefix(uri, "https://") {
				t.Error("URI should use HTTPS")
			}
			if !strings.Contains(uri, tt.domain) {
				t.Error("URI should contain domain")
			}
			if tt.username != "" && !strings.Contains(uri, tt.username) {
				t.Error("URI should contain username")
			}
			if tt.expected != "" && !strings.HasPrefix(uri, tt.expected) {
				t.Errorf("Expected URI to start with %s, got %s", tt.expected, uri)
			}
		})
	}
}

func TestActivityAddressing(t *testing.T) {
	// Test public addressing patterns
	publicURI := "https://www.w3.org/ns/activitystreams#Public"
	followersURI := "https://stegodon.example/users/alice/followers"

	// Test addressing arrays
	to := []string{publicURI}
	cc := []string{followersURI}

	if len(to) != 1 || to[0] != publicURI {
		t.Error("Expected public URI in 'to' field")
	}
	if len(cc) != 1 || cc[0] != followersURI {
		t.Error("Expected followers URI in 'cc' field")
	}

	// Verify JSON serialization
	addressing := map[string]any{
		"to": to,
		"cc": cc,
	}

	jsonBytes, _ := json.Marshal(addressing)
	var parsed map[string]any
	json.Unmarshal(jsonBytes, &parsed)

	parsedTo := parsed["to"].([]any)
	if parsedTo[0] != publicURI {
		t.Error("Public URI should be preserved in JSON")
	}
}

func TestMustMarshal(t *testing.T) {
	// Test mustMarshal helper function
	tests := []struct {
		name  string
		input any
		want  string
	}{
		{
			name:  "simple string",
			input: "hello",
			want:  `"hello"`,
		},
		{
			name:  "map",
			input: map[string]string{"type": "Follow"},
			want:  `{"type":"Follow"}`,
		},
		{
			name:  "array",
			input: []string{"a", "b"},
			want:  `["a","b"]`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := mustMarshal(tt.input)
			if result != tt.want {
				t.Errorf("Expected %s, got %s", tt.want, result)
			}
		})
	}
}

func TestMustMarshalPanic(t *testing.T) {
	// Test that mustMarshal panics on error (e.g., channels cannot be marshaled)
	defer func() {
		if r := recover(); r == nil {
			t.Error("Expected mustMarshal to panic on unmarshallable type")
		}
	}()

	ch := make(chan int)
	mustMarshal(ch) // Should panic
}

func TestActivityTimestamps(t *testing.T) {
	// Test RFC3339 timestamp formatting
	now := time.Now()
	formatted := now.Format(time.RFC3339)

	// Verify format is correct
	if !strings.Contains(formatted, "T") {
		t.Error("RFC3339 should contain T separator")
	}
	if !strings.Contains(formatted, ":") {
		t.Error("RFC3339 should contain time separators")
	}

	// Parse back to verify
	parsed, err := time.Parse(time.RFC3339, formatted)
	if err != nil {
		t.Fatalf("Failed to parse RFC3339 timestamp: %v", err)
	}

	// Times should be equal within a second
	if parsed.Sub(now) > time.Second || now.Sub(parsed) > time.Second {
		t.Error("Timestamp parsing should preserve time accurately")
	}
}

func TestDeliveryQueueItemCreation(t *testing.T) {
	// Test creating delivery queue items
	inboxURI := "https://mastodon.social/inbox"
	activity := map[string]string{"type": "Create"}
	activityJSON := mustMarshal(activity)

	queueItem := &domain.DeliveryQueueItem{
		Id:           uuid.New(),
		InboxURI:     inboxURI,
		ActivityJSON: activityJSON,
		Attempts:     0,
		NextRetryAt:  time.Now(),
		CreatedAt:    time.Now(),
	}

	if queueItem.InboxURI != inboxURI {
		t.Error("InboxURI should be set correctly")
	}
	if queueItem.Attempts != 0 {
		t.Error("New queue items should start with 0 attempts")
	}
	if queueItem.ActivityJSON != activityJSON {
		t.Error("Activity JSON should be stored")
	}

	// Verify activity can be unmarshaled
	var parsedActivity map[string]string
	if err := json.Unmarshal([]byte(queueItem.ActivityJSON), &parsedActivity); err != nil {
		t.Error("Stored activity JSON should be valid")
	}
	if parsedActivity["type"] != "Create" {
		t.Error("Activity should be preserved in queue")
	}
}

func TestHTTPHeaders(t *testing.T) {
	// Test that we set proper headers for ActivityPub
	contentType := "application/activity+json"
	accept := "application/activity+json"
	userAgent := "stegodon/1.0 ActivityPub"

	if contentType != "application/activity+json" {
		t.Error("Content-Type should be application/activity+json")
	}
	if accept != "application/activity+json" {
		t.Error("Accept should be application/activity+json")
	}
	if !strings.Contains(userAgent, "stegodon") {
		t.Error("User-Agent should identify as stegodon")
	}
}

func TestDigestCalculation(t *testing.T) {
	// Test digest header calculation for HTTP signatures
	activityJSON := []byte(`{"type":"Follow"}`)

	// This is what SendActivity does
	hash := sha256.Sum256(activityJSON)
	digest := "SHA-256=" + base64.StdEncoding.EncodeToString(hash[:])

	if !strings.HasPrefix(digest, "SHA-256=") {
		t.Error("Digest should have SHA-256= prefix")
	}
	if len(digest) < 50 {
		t.Error("Digest should contain base64 encoded hash")
	}

	// Verify the same input produces same digest
	hash2 := sha256.Sum256(activityJSON)
	digest2 := "SHA-256=" + base64.StdEncoding.EncodeToString(hash2[:])
	if digest != digest2 {
		t.Error("Same input should produce same digest")
	}
}

func TestKeyIDFormat(t *testing.T) {
	// Test key ID formatting for HTTP signatures
	domain := "stegodon.example"
	username := "alice"
	keyID := "https://" + domain + "/users/" + username + "#main-key"

	if !strings.HasPrefix(keyID, "https://") {
		t.Error("Key ID should use HTTPS")
	}
	if !strings.Contains(keyID, username) {
		t.Error("Key ID should contain username")
	}
	if !strings.HasSuffix(keyID, "#main-key") {
		t.Error("Key ID should end with #main-key")
	}

	expectedFormat := "https://stegodon.example/users/alice#main-key"
	if keyID != expectedFormat {
		t.Errorf("Expected key ID %s, got %s", expectedFormat, keyID)
	}
}

func TestPublicURIConstant(t *testing.T) {
	// Test the public addressing constant
	publicURI := "https://www.w3.org/ns/activitystreams#Public"

	if !strings.HasPrefix(publicURI, "https://") {
		t.Error("Public URI should use HTTPS")
	}
	if !strings.Contains(publicURI, "activitystreams") {
		t.Error("Public URI should reference ActivityStreams")
	}
	if !strings.HasSuffix(publicURI, "#Public") {
		t.Error("Public URI should end with #Public")
	}
}

func TestContextURI(t *testing.T) {
	// Test ActivityStreams context URI
	contextURI := "https://www.w3.org/ns/activitystreams"

	if !strings.HasPrefix(contextURI, "https://") {
		t.Error("Context URI should use HTTPS")
	}
	if !strings.Contains(contextURI, "w3.org") {
		t.Error("Context should be from W3C")
	}
}

// Tests for Undo activity (unfollow)

func TestUndoActivityGeneration(t *testing.T) {
	// Test Undo activity structure for unfollowing
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  actorURI,
			"object": remoteActorURI,
		},
	}

	// Verify structure can be marshaled
	jsonBytes, err := json.Marshal(undo)
	if err != nil {
		t.Fatalf("Failed to marshal Undo activity: %v", err)
	}

	// Parse back to verify structure
	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Undo: %v", err)
	}

	if parsed["type"] != "Undo" {
		t.Errorf("Expected type Undo, got %v", parsed["type"])
	}
	if parsed["actor"] != actorURI {
		t.Errorf("Expected actor %s, got %v", actorURI, parsed["actor"])
	}

	// Verify embedded Follow object
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Follow" {
		t.Error("Expected embedded object type Follow")
	}
	if obj["id"] != followID {
		t.Error("Expected embedded object to reference original Follow")
	}
	if obj["actor"] != actorURI {
		t.Error("Expected Follow actor to match Undo actor")
	}
	if obj["object"] != remoteActorURI {
		t.Error("Expected Follow object to be remote actor URI")
	}
}

func TestUndoActivityStructureValidation(t *testing.T) {
	// Test that Undo activity follows ActivityPub specification
	// https://www.w3.org/TR/activitypub/#undo-activity
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  actorURI,
			"object": remoteActorURI,
		},
	}

	jsonBytes, err := json.Marshal(undo)
	if err != nil {
		t.Fatalf("Failed to marshal Undo activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Undo: %v", err)
	}

	// Required fields
	if parsed["@context"] == nil {
		t.Error("Undo activity must have @context")
	}
	if parsed["id"] == nil {
		t.Error("Undo activity must have id")
	}
	if parsed["type"] != "Undo" {
		t.Error("Undo activity must have type 'Undo'")
	}
	if parsed["actor"] == nil {
		t.Error("Undo activity must have actor")
	}
	if parsed["object"] == nil {
		t.Error("Undo activity must have object")
	}

	// Object must be a Follow activity (for unfollow)
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Follow" {
		t.Error("For unfollow, Undo object must be a Follow activity")
	}

	// The Follow's actor should match the Undo's actor
	if obj["actor"] != parsed["actor"] {
		t.Error("Follow actor should match Undo actor")
	}
}

func TestUndoFollowWorkflow(t *testing.T) {
	// Test the complete unfollow workflow structure
	// 1. Original Follow was sent
	// 2. Now sending Undo to cancel it

	// Original Follow
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	targetURI := "https://mastodon.social/users/bob"

	originalFollow := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       followID,
		"type":     "Follow",
		"actor":    actorURI,
		"object":   targetURI,
	}

	// Verify original Follow is valid
	followJSON, err := json.Marshal(originalFollow)
	if err != nil {
		t.Fatalf("Failed to marshal Follow: %v", err)
	}

	var parsedFollow map[string]any
	if err := json.Unmarshal(followJSON, &parsedFollow); err != nil {
		t.Fatalf("Failed to parse Follow: %v", err)
	}

	// Now create Undo that references this Follow
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object":   originalFollow, // Embed the entire Follow
	}

	undoJSON, err := json.Marshal(undo)
	if err != nil {
		t.Fatalf("Failed to marshal Undo: %v", err)
	}

	var parsedUndo map[string]any
	if err := json.Unmarshal(undoJSON, &parsedUndo); err != nil {
		t.Fatalf("Failed to parse Undo: %v", err)
	}

	// Verify the embedded Follow is intact
	embeddedFollow := parsedUndo["object"].(map[string]any)
	if embeddedFollow["id"] != followID {
		t.Error("Embedded Follow should retain original ID")
	}
	if embeddedFollow["type"] != "Follow" {
		t.Error("Embedded object should be Follow")
	}
	if embeddedFollow["actor"] != actorURI {
		t.Error("Embedded Follow should have same actor as Undo")
	}
}

func TestUndoActivityComparison(t *testing.T) {
	// Compare Undo structure with other activities to ensure consistency
	actorURI := "https://stegodon.example/users/alice"
	targetURI := "https://mastodon.social/users/bob"

	// Follow activity
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	follow := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       followID,
		"type":     "Follow",
		"actor":    actorURI,
		"object":   targetURI,
	}

	// Undo activity
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object":   follow,
	}

	// Both should have required fields
	for _, activity := range []map[string]any{follow, undo} {
		if activity["@context"] == nil {
			t.Error("All activities must have @context")
		}
		if activity["id"] == nil {
			t.Error("All activities must have id")
		}
		if activity["type"] == nil {
			t.Error("All activities must have type")
		}
		if activity["actor"] == nil {
			t.Error("All activities must have actor")
		}
		if activity["object"] == nil {
			t.Error("All activities must have object")
		}
	}

	// IDs should be unique
	if follow["id"] == undo["id"] {
		t.Error("Follow and Undo should have different IDs")
	}

	// Actors should be the same (same person unfollowing)
	if follow["actor"] != undo["actor"] {
		t.Error("Follow and Undo should have same actor for unfollow")
	}
}

func TestUndoJSONMarshaling(t *testing.T) {
	// Test that Undo activity can be marshaled and unmarshaled without data loss
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	targetURI := "https://mastodon.social/users/bob"

	original := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  actorURI,
			"object": targetURI,
		},
	}

	// Marshal
	jsonBytes, err := json.Marshal(original)
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal
	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify all fields preserved
	if parsed["id"] != original["id"] {
		t.Error("ID should be preserved")
	}
	if parsed["type"] != original["type"] {
		t.Error("Type should be preserved")
	}
	if parsed["actor"] != original["actor"] {
		t.Error("Actor should be preserved")
	}

	// Verify nested object preserved
	originalObj := original["object"].(map[string]any)
	parsedObj := parsed["object"].(map[string]any)

	if parsedObj["id"] != originalObj["id"] {
		t.Error("Nested Follow ID should be preserved")
	}
	if parsedObj["type"] != originalObj["type"] {
		t.Error("Nested Follow type should be preserved")
	}
	if parsedObj["actor"] != originalObj["actor"] {
		t.Error("Nested Follow actor should be preserved")
	}
	if parsedObj["object"] != originalObj["object"] {
		t.Error("Nested Follow object should be preserved")
	}
}

// Tests for self-follow prevention

func TestSelfFollowDetection(t *testing.T) {
	// Test detection of self-follow attempt (same domain and username)
	sslDomain := "stegodon.example"
	username := "alice"

	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: username,
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: username,
		Domain:   sslDomain,
		ActorURI: "https://" + sslDomain + "/users/" + username,
	}

	// Check if this is a self-follow attempt
	isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

	if !isSelfFollow {
		t.Error("Should detect self-follow when domain and username match")
	}
}

func TestSelfFollowDetectionDifferentUser(t *testing.T) {
	// Test that different users on same domain are not detected as self-follow
	sslDomain := "stegodon.example"

	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: "alice",
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob", // Different user
		Domain:   sslDomain,
		ActorURI: "https://" + sslDomain + "/users/bob",
	}

	// Check if this is a self-follow attempt
	isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

	if isSelfFollow {
		t.Error("Should NOT detect self-follow when usernames differ")
	}
}

func TestSelfFollowDetectionDifferentDomain(t *testing.T) {
	// Test that same username on different domain is not detected as self-follow
	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: "alice",
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "alice",           // Same username
		Domain:   "mastodon.social", // Different domain
		ActorURI: "https://mastodon.social/users/alice",
	}

	localDomain := "stegodon.example"

	// Check if this is a self-follow attempt
	isSelfFollow := (remoteActor.Domain == localDomain && remoteActor.Username == localAccount.Username)

	if isSelfFollow {
		t.Error("Should NOT detect self-follow when domains differ")
	}
}

func TestSelfFollowErrorMessage(t *testing.T) {
	// Test that self-follow error message is user-friendly
	errMsg := "self-follow not allowed on stegodon for now"

	if !strings.Contains(strings.ToLower(errMsg), "self-follow") {
		t.Error("Error message should mention 'self-follow'")
	}

	if !strings.Contains(strings.ToLower(errMsg), "not allowed") {
		t.Error("Error message should indicate it's not allowed")
	}

	if !strings.Contains(strings.ToLower(errMsg), "stegodon") {
		t.Error("Error message should mention stegodon")
	}

	// Should not be too technical
	if strings.Contains(errMsg, "error") || strings.Contains(errMsg, "failed") {
		t.Error("Error message should be user-friendly, not technical")
	}
}

func TestSelfFollowPreventionTiming(t *testing.T) {
	// Test that self-follow check happens early (before database operations)
	// This is important to avoid unnecessary database writes

	// In the actual SendFollow function, the check order is:
	// 1. Fetch remote actor (GetOrFetchActor)
	// 2. Check if self-follow â† THIS SHOULD HAPPEN HERE
	// 3. Check if already following (database read)
	// 4. Create follow record (database write)

	// The self-follow check should happen at step 2, before any database operations
	// This test verifies the logic is correct

	sslDomain := "stegodon.example"
	username := "alice"

	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: username,
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: username,
		Domain:   sslDomain,
		ActorURI: "https://" + sslDomain + "/users/" + username,
	}

	// Check self-follow BEFORE any other operations
	isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

	if !isSelfFollow {
		t.Fatal("Failed to detect self-follow at early stage")
	}

	// If we get here, we would return early and NOT proceed with:
	// - Database read for existing follow
	// - Database write for new follow
	// This is the desired behavior
}

func TestSelfFollowCaseSensitivity(t *testing.T) {
	// Test that username comparison is case-sensitive (ActivityPub standard)
	sslDomain := "stegodon.example"

	tests := []struct {
		name           string
		localUsername  string
		remoteUsername string
		shouldMatch    bool
	}{
		{
			name:           "Exact match",
			localUsername:  "alice",
			remoteUsername: "alice",
			shouldMatch:    true,
		},
		{
			name:           "Different case",
			localUsername:  "alice",
			remoteUsername: "Alice",
			shouldMatch:    false, // ActivityPub usernames are case-sensitive
		},
		{
			name:           "All uppercase",
			localUsername:  "alice",
			remoteUsername: "ALICE",
			shouldMatch:    false,
		},
		{
			name:           "Different users",
			localUsername:  "alice",
			remoteUsername: "bob",
			shouldMatch:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			localAccount := &domain.Account{
				Id:       uuid.New(),
				Username: tt.localUsername,
			}

			remoteActor := &domain.RemoteAccount{
				Id:       uuid.New(),
				Username: tt.remoteUsername,
				Domain:   sslDomain,
				ActorURI: "https://" + sslDomain + "/users/" + tt.remoteUsername,
			}

			isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

			if isSelfFollow != tt.shouldMatch {
				t.Errorf("Expected isSelfFollow=%v for local=%s remote=%s, got %v",
					tt.shouldMatch, tt.localUsername, tt.remoteUsername, isSelfFollow)
			}
		})
	}
}

func TestSelfFollowDomainComparison(t *testing.T) {
	// Test that domain comparison works correctly
	tests := []struct {
		name         string
		localDomain  string
		remoteDomain string
		shouldMatch  bool
	}{
		{
			name:         "Same domain",
			localDomain:  "stegodon.example",
			remoteDomain: "stegodon.example",
			shouldMatch:  true,
		},
		{
			name:         "Different domains",
			localDomain:  "stegodon.example",
			remoteDomain: "mastodon.social",
			shouldMatch:  false,
		},
		{
			name:         "Subdomain difference",
			localDomain:  "stegodon.example.com",
			remoteDomain: "mastodon.example.com",
			shouldMatch:  false,
		},
		{
			name:         "Port in domain",
			localDomain:  "stegodon.example:3000",
			remoteDomain: "stegodon.example",
			shouldMatch:  false, // Should be exact match
		},
	}

	username := "alice"

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			localAccount := &domain.Account{
				Id:       uuid.New(),
				Username: username,
			}

			remoteActor := &domain.RemoteAccount{
				Id:       uuid.New(),
				Username: username,
				Domain:   tt.remoteDomain,
				ActorURI: "https://" + tt.remoteDomain + "/users/" + username,
			}

			isSelfFollow := (remoteActor.Domain == tt.localDomain && remoteActor.Username == localAccount.Username)

			if isSelfFollow != tt.shouldMatch {
				t.Errorf("Expected isSelfFollow=%v for local=%s remote=%s, got %v",
					tt.shouldMatch, tt.localDomain, tt.remoteDomain, isSelfFollow)
			}
		})
	}
}
